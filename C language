一.一切皆地址
1.c用变量存储数据，用函数定义一段可重复使用的代码，它们最终都要放在内存中才能供CPU使用。
  拥有读取和执行权限的内存块就是代码，而拥有读取和写入权限（也可能只有读取权限）的内存块就是数据。
  
2.数据和代码都以二进制的形式存储在内存中，CPU只能通过地址来访问数据和代码。

3.CPU 访问内存时需要的是地址，而不是变量名和函数名！
  变量名和函数名只是地址的一种助记符，当源文件被编译和链接成可执行程序后，它们都会被替换成地址。
  编译和链接过程的一项重要任务就是找到这些名称所对应的地址。
  
二.定义指针变量
1.
//定义指针变量
float *p1 = &a;
char *p2 = &c;
//修改指针变量的值
p1 = &b;
p2 = &d;
*是一个特殊符号，表明一个变量是指针变量，定义 p1、p2 时必须带*。
而给 p1、p2 赋值时，因为已经知道了它是一个指针变量，就没必要多此一举再带上*，
后边可以像使用普通变量一样来使用指针变量。也就是说，定义指针变量时必须带*，给指针变量赋值时不能带*。

2.*&a,&*pa代表的意思是?
*&a=*(&a),$a=p,*p=a
&*pa=&(*pa),*pa=a,&a=pa

三.c语言数组指针（指向数组的指针）
如果一个指针指向了数组，我们就称它为数组指针（Array Pointer）
int arr[] = { 99, 15, 100, 888, 252 };
int *p = arr;
arr 是数组第 0 个元素的地址，所以int *p = arr;也可以写作int *p = &arr[0];。
也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。

引入数组指针后，我们就有两种方案来访问数组元素了，一种是使用下标，另外一种是使用指针。
1) 使用下标：也就是采用 arr[i] 的形式访问数组元素。
如果 p 是指向数组 arr 的指针，那么也可以使用 p[i] 来访问数组元素，它等价于 arr[i]。
2) 使用指针：也就是使用 *(p+i) 的形式访问数组元素。
另外数组名本身也是指针，也可以使用 *(arr+i) 来访问数组元素，它等价于 *(p+i)。

不管是数组名还是数组指针，都可以使用上面的两种方式来访问数组元素。
不同的是，数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。
也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。

借助自增运算符来遍历数组元素：
#include <stdio.h>
int main(){
    int arr[] = { 99, 15, 100, 888, 252 };
    int i, *p = arr, len = sizeof(arr) / sizeof(int);
    for(i=0; i<len; i++){
        printf("%d  ", *p++ );
    }
    printf("\n");
    return 0;
}
运行结果：
99  15  100  888  252

第 8 行代码中，*p++ 应该理解为 *(p++)，每次循环都会改变 p 的值（p++ 使得 p 自身的值增加），
以使 p 指向下一个数组元素。该语句不能写为 *arr++，因为 arr 是常量，而 arr++ 会改变它的值，这显然是错误的。

关于数组指针的谜题

假设 p 是指向数组 arr 中第 n 个元素的指针，那么 *p++、*++p、(*p)++ 分别是什么意思呢？

*p++ 等价于 *(p++)，表示先取得第 n 个元素的值，再将 p 指向下一个元素，上面已经进行了详细讲解。

*++p 等价于 *(++p)，会先进行 ++p 运算，使得 p 的值增加，指向下一个元素，
整体上相当于 *(p+1)，所以会获得第 n+1 个数组元素的值。

(*p)++ 就非常简单了，会先取得第 n 个元素的值，再对该元素的值加 1。
假设 p 指向第 0  个元素，并且第 0 个元素的值为 99，执行完该语句后，第 0  个元素的值就会变为 100。



